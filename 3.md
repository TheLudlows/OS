#### 3.1 内存概述

内存用来放数据，程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾。内存地址从0 开始，每个 地址对应一 个存储单元。

操作系统作为系统资源的管理者，当然也需要对内存 进行管理

1. 操作系统负责内存空间的分配与回收，分为连续分配和非连续分配
2. 提供某种技术从逻辑上对内存空间进行扩充
3. 供地址转换功能，负责程序的逻辑地址与物理地 址的转换
4. 提供内存保护功能。保证各进程在各自存储空间内 运行，互不干扰

#### 3.2 地址转换

为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换（重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要关注 物理内存的实际情况。

三种装入方式

- 绝对装入，编译时产生绝对地址
- 可重入装入，装入时将逻辑地址转换为物理地址
- 动态运行时装入，运行时将逻辑地址转换为物理地址，需设置重定位寄存器，也是现代操作系统使用的方式

#### 3.3内存保护

内存保护可采取两种方法一是在CPU中设置一对上、下限寄存器，存放 进程的上、下限地址。进程的指令要访问某个地址 时，CPU检查是否越界。二是采用重定位寄存器（又称基址寄存器）和界 地址寄存器（又称限长寄存器）进行越界检查。重定 位寄存器中存放的是进程的起始物理地址。界地址寄 存器中存放的是进程的最大逻辑地址。

#### 3.4 覆盖和交换

覆盖技术的思想：将程序分为多个段（多个模块）。 常用的段常驻内存，不常用的段在需要时调入内存。 内存中分为一个固定区和若干个“覆盖区。 需要常驻内存的段放在固定区中，调入后就不再 调出（除非运行结束） 不常用的段放在覆盖区，需要用到时调入内存， 用不到时调出内存。必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点：对用户不透明，增加了用户编程负担。 覆盖技术只用于早期的操作系统中，现在已成为历史。

交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中 某些已具备运行条件的进程换入内存，进程在内存与磁盘间动态调度。暂时换出外存等待的进程状态为挂起状态（挂起态，suspend） 挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。

中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。

1. 具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件 区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采 用离散分配方式；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放 在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理 主要追求换入换出速度，因此通常对换区采用连续分配方式（。总之，对换区的I/O速度比文件区的更快。
2.   交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在 发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程； 如果缺页率明显下降，就可以暂停换出。
3.  可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调 入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间

另外PCB 会常驻内存，不会被换出外存。



#### 3.5 连续分配

连续分配指为用户进程分配的必须是一个连续的内存空间，分为单一连续分配、固定分区分配和动态分区分配。

内部碎片，分配给某进程的内存区域中，如果有些部分没有用上。 外部碎片，是指内存中的某些空闲分区由于太小而难以利用。

在单一连续分配方式中，内存被分为系统区和用户区。 系统区通常位于内存的低地址部分，用于存放操作系统 相关数据；用户区用于存放用户进程相关数据。 内存中只能有一道用户程序，用户程序独占整个用户区 空间。存在于早期的 PC 操作 系统 MS-DOS。

为了能在内 存中装入多道程序，且这些程序之间又不会相互干扰， 于是将整个用户空间划分为若干个固定大小的分区，在 每个分区中只装入一道作业，这样就形成了最早的、最 简单的一种可运行多道程序的内存管理方式。固定分配分为两类

- 分区大小相等：缺乏灵活性，但是很适合用于用一台计 算机控制多个相同对象的场合
- 分区大小不等：增加了灵活性，可以满足不同大小的进 程需求。根据常在系统中运行的作业大小情况进行划分。操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回 收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的 大小、起始地址、状态。该方式会产生内部碎片，内存利用率低。

动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时， 根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数 目是可变的。

系统要用需记录内存的使用情况，有两种方式

- 空闲分区表：每 个空闲分区对应 一个表项。表项 中包含分区号、 分区大小、分区 起始地址等信息
- 空闲分区链：每个分区的起始部分和末尾部分分别设置前向指 针和后向指针。起始部分处还可记录分区大小等信息

动态分区分配回收内存时相邻的空闲分区要合并。

动态分区分配没有内部碎片，但是有外部碎片。可以通过紧凑（拼凑，Compaction）技术来解决外部碎片。



| 算法     | 算法思想                                             | 分区排列顺序                | 优点                                                         | 缺点                                                         |
| -------- | ---------------------------------------------------- | --------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 首次适应 | 从头到尾找适合的 分区                                | 空闲分区以地址 递增次序排列 | 综合看性能最好。算 法开销小，回收分区 后一般不需要对空闲 分区队列重新排序 |                                                              |
| 最佳适应 | 优先使用更小的分 区，以保留更多大 分区               | 空闲分区以容量 递增次序排列 | 会有更多的大分区被 保留下来，更能满足 大进程需求             | 会产生很多太小的、难以 利用的碎片；算法开销大， 回收分区后可能需要对空 闲分区队列重新排序 |
| 最坏适应 | 优先使用更大的分 区，以防止产生太 小的不可用的碎片   | 空闲分区以容量递减次序排列  | 可以减少难以利用的 小碎片                                    | 大分区容易被用完，不利 于大进程；算法开销大                  |
| 邻近适应 | 由首次适应演变而 来，每次从上次查 找结束位置开始查找 | 空闲分区以地址 递增次序排列 | 不用每次都从低地址 的小分区开始检索。 算法开销小             | 会使高地址的大分区也被 用完                                  |

#### 3.6非连续分配

为用户进程分配的可以是一些分散的内存空间，分为基本分页存储、基本分段存储和段页式存储。
##### 3.6.1 分页存储
将内存空间分为一个个大小相等的分区如每个分区4KB，每个分区就是一个页框（也叫页帧、内存块、物理块、物理页面）。每个页框有一个编号，即页框号页框号从0开始。

将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个页或页面。每个页面也有一个编号，即页号，页号也是从0开始。

操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。各个页面不必连续存放，可以放到不相邻的各个页框中。进程的最后一个页面可能没有一个页框那么大。也就是说，分页存储有可能产生内部碎片，因此页框不能太大，否则可能产生过大的内部碎片造成浪费。

为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。页表通常存在PCB（进程控制块）中。一个进程对应一张页表，进程的每个页面对应一个页表项， 每个页表项由页号和块号组成，页表记录进程页面和实际存放的内存块之间的映射关系，每个页表项的长度是相同的。

页表项连续存放，因此页号可以是隐含的，不占存储空间，块号取决于内存的大小。

虽然进程的各个页面是离散存放的，但是页面内部是连续存放的

**如何确定一个逻辑地址对应的页号、页内偏移量？**
页号 = 逻辑地址 / 页面长度
页内偏移量 = 逻辑地址 % 页面长度

通过页号查询页表，可知页面在内存中的起始地址页面在内存中的起始地址+页内偏移量 = 实际的物理地址

##### 基本地址转换机构

基本地址转换机构用于实现逻辑地址到物理地址转换的一组硬件机构。

基本地址转换机构借助进程的页表将逻辑地址转换为物理地址，通常会在系统中设置一个页表寄存器PTR，存放页表在内存中的起始地址和也变长度。进程未执行时，页表的地址和长度放在进程控制块中，当进程被调度，系统会把他们放入页表寄存器中。

假设页面大小为L，逻辑地址A到物理地址E的变换过程如下

1. 计算页号P和页内偏移量W，P=A/L，W=A%A
2. 比较页号P和页表长度M，若P>= M，则产生越界中断，否则继续执行
3. 页表中页号P对应的也表项地址= 页表其实地址F+页号P*页表项长度，取出该页表项的内容即为内存块号B
4. E = B*L + W

为了方便页表的查询，常常让每个页表项用4byte存放。

TLB

快表又称联想寄存器(TLB， translation lookaside buffer )，是一种访问速度比内存快很多的高速缓存(TLB不是内存)，用来存放最近访问的页表项的副本，可以加速地址变换的速度。 与此对应内存中的页表常称为慢表。

二级页表

页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。把页表再分页并离散存储，然后再建立一张页表记录页表各个部分的存放位置，称为页目录表，或称外层页表，或称顶层页表

比如32位逻辑地址空间，页表项大小为4B，页面大小为 4KB，则页内地址占12位。进程最多有 $2^{20}$ 个页面，  用 20 位二进制刚好可以表示 $0-(2^{20}-1) $个页号。 每个页面可存放 $4K/4 =1K = 2^{10} = 1024 $个页表项。逻辑地址 (0000000000,0000000001,111111111111)，按照地址结构将逻辑地址拆分成三部分，从PCB 中读出页目录表始址，再根据一级页号查页目录 表，找到下一级页表在内存中的存放位置，根据二级页号查二级页表，找到最终想访问的内存块号。