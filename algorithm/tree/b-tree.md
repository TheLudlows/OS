

与二叉查找树、红黑树等不同，B树适用于读写相对大的数据块的存储系统，B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。

在红黑树中提到的2-3树、2-3-4树都属于B-tree，往往实际中使用的是阶数更高的B-tree。 *阶* 定义为最大数量的子节点树。

一个 $m$阶的B树是一个有以下属性的树：

1. 每一个节点最多有 *m* 个子节点
2. 每一个非叶子节点及根节点最少有 $┌m/2┐$个子节点，也就是非叶子及根节点至少包含$┌m/2┐-1$个关键字
3. 如果根节点不是叶子节点，那么它至少有两个子节点
4. 有 *k* 个子节点的非叶子节点拥有 $k − 1$个键，并且按照递增次序排序
5. 所有的叶子节点都在同一层，并且不带信息(实际上这些结点不存在，指向这些结点的指针为空)。

比较难理解的是第二条，比如3阶B树，通常称为2-3树只能包含2节点和3节点，再比如10阶B树，只能包含5～10节点。

>$┌m/2┐$是向上取整,即取与结果最接近的比结果大的整数,$┌3/2┐$=2
>$└m/2┘$是向下取整,即取与结果最接近的比结果小的整数,$└3/2┘$=1

##### 查找操作

B树的查询与二叉树的搜索基本类似，首先从跟节点出发，拿到根节点（可能是从磁盘中读取），遍历节点的关键字或者用二分法查找，如果找到则检索成功。否则需要确定要查的关键码值是在某个ki和ki+1之间，然后取ki所指向的节点继续查找，如果最终仍然没有找到，就返回失败，成功则返回要检索的值。 

##### 插入操作

从根结点开始寻找，如果不存在元素，在查询结束处的节点插入该元素，如果节点的关键字数没有超过了限制(-特性4)，直接插入并结束。如果超过了限制，那么情况稍微复杂一些，将节点分裂为3份，取中间关键字至父节点，，左右的键分为两个节点。如果父节点也超过了关键字限制，一直向上递归直至跟结点。若跟结点也超过限制，此时树的高度增加。

##### 删除操作

1. 如果当前需要删除的键位于非叶子结点上，则用后继键覆盖要删除的键，然后在后继键所在的节点中删除该键。
2. 该节点键个数大于等于$Math.ceil(m/2)-1$，结束删除操作,否则进入3
3. 如果左右兄弟结点任意一个键个数大于$Math.ceil(m/2)-1$，则父结点中的key下移到该节点，兄弟结点中的一个键上移，删除操作结束。否则进入4
4. 将父结点中的键下移与当前节点及它的兄弟节点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了一个孩子指针，指向这个新结点。然后当前结点的指针指向父节点，若重复上第2步。

因为前面讲的[2-3树](./src/2-3treee.md)插入删除操作的扩展，此处就不展开解释了。可以在此网站调试理解https://www.cs.usfca.edu/~galles/visualization/BTree.html



#### B+树

目前B+树的定义不统一，有两种主流的版本，分别是维基百科的方式以及Mysql中B+树,两者的差异主要表现在非叶子节点中的键的个数。

- 英文版的维基百科中描述为：$n$阶的B+树非叶子节点最多包含$n-1$个键，即$n$棵子树的节点中含有$n-1$个关键字。在[usfca](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)官网的可视化工具中与此描述一致。

- 还有一种Mysql版本的b+树：$n$阶的B+树最多有$n$个关键字，即$n$棵子树的节点中含有$n$个关键字，

除此之外，两者相同的特性如下：叶子节点保存了所有键和数据信息，叶子节点之间连通形成顺序列表，有利于遍历数据。

不管是哪种定义方式，B+树的基本方向是确定的，通过非叶子节点的索引查询叶子节点中的数据。叶子节点形成的链表有利于数据的遍历。

#### B*-tree

B*-tree是***\*B+-tree\****的变体，在***\*B+\****树的基础上(所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针)，B*树中非根和非叶子结点再增加指向兄弟的指针。

B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）



Ref

https://blog.csdn.net/v_JULY_v/article/details/6530142#commentBox

https://web.cs.ucdavis.edu/~green/courses/ecs165b-s10/Lecture6.pdf

https://www.cs.usfca.edu/~galles/visualization/Algorithms.html