#### 1. 机器级代码

计算机系统使用了多种不同形式的抽象，利用简单的抽象模型来隐藏实现的细节。对于机器级编程来说，两种抽象尤为重要，一是由指令集体系结构货指令集架构(Instruction Set Architecture)来定义机器级程序的格式和行为，也定义了处理器状态，指令的格式，以及每条指令对状态的影响。第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去像一个大数组。

在编译过程中，编译器完成大部分的工作，以C为例，它把C语言提供的相对抽象的执行模型转化为处理器执行的基本指令。汇编代码和二进制的机器码相比更具有可读性。

##### 2.1 操作数

大多数指令有一个或者多个操作数(operand)，指示除操作中使用的源数据以及目标位置。源数据可以是常数、寄存器中的数据或内存中的数据。结果可以防砸寄存器或内存中。因此操作数可以分为三种类型，第一立即数(immediate)也就是常数，以美元符开头，如\$0x1F。第二种是寄存器，他表示某个寄存器的内容，一般用$r_a$表示a寄存器，则$R[r_a]$表示寄存器的内容。第三种是内存操作数，它会根据计算出来的地址访问某个内存位置$M_b[Add]$，b表示长度。格式与操作数的值如下。

![](./1.png)

#### 2.2 数据传输指令

最简单的传送指令MOV，分别由movb、movw、movl和movq组成。这些指令执行同样的操作，区别在于操作数据大小不同。分别是1、2、4、8个字节。该指令的源操作数是一个立即数，存储在寄存器或者内存中，目的操作数制定一个位置，要么是一个寄存器要么是一个内存地址。x86-64加了一条限制，传送指令的两个操作数不能都指向内存的位置。这些指令的寄存器操作数可以是16个通用寄存器中的任意一个。如下案例

```assembly
 movl $0x4550,%eax Imm -> Reg 4bytes
 movw %bp,%bp Reg -> Reg 2bytes
 movb (%rd1,%rcx),%al Mem -> Reg 1byte
 movq %rax,-12(%rbp) Reg -> Mem 8bytes
```

movq只能以表示为32位补码立即数作为源操作数，然后把这个值扩展到64位放入目的位置。movabbsq指令能够将任意64位立即数作为源操作数，但只能以寄存器为目的。

![](./2.png)